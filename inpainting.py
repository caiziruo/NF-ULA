from ULA_NF import *

######### load NF and PnP denoisers from pre-trained model, or load the model trained by yourself.
pt_NF = "./glow_pytorch_rosinality/checkpoint/model_additive_100.pt"
pt_PnP = './Provable_Plug_and_Play/training/logs/2023-01-13/DnCNN_Sigma5_17Layers_modeS_LipConst/epoch48_noise5_PSNR41.03_SSIM0.98.pth'
# pt_PnP = './Provable_Plug_and_Play/training/logs/2023-01-13/DnCNN_Sigma5_17Layers_modeS_LipConst/epoch47_noise5_PSNR41.06_SSIM0.98.pth' 
# pt_PnP = './Provable_Plug_and_Play/training/logs/2023-01-13/DnCNN_Sigma5_17Layers_modeS_LipConst/epoch48_noise5_PSNR41.03_SSIM0.98.pth'  
# pt_PnP = './Provable_Plug_and_Play/training/logs/2023-01-13/DnCNN_Sigma5_17Layers_modeS_LipConst/epoch50_noise5_PSNR41.09_SSIM0.98.pth'  

# noise_variance   = 0.0004        # do not change this if load_observation = True
# step_size        = 5e-5          # stepsize for NF-ULA and PnP-ULA. 
# alpha            = 2.0           # regularization parameter of the prior.
# sample_size      = 10000         # the number of samples you want to generate.
# figure_name      = face1, face2, face3, face4
# load_observation = True          # True: load from existing observation.pt. False: generate another observation by y = Ax + noise.
# projection_C     = 100           # the projection onto the compact set [-(projection_C-1), projection_C]^d
# lambda_Moreau    = 5e-5          # parameter of the Moreau envelope of the projection C.

ULA_NF_test = ULA_NF(problem = 'inpainting', noise_variance = 0.0004, step_size = 5e-5, alpha = 2.0, sample_size = 10000, figure_name = 'face1', load_observation = True, projection_C = 100.0, lambda_Moreau = 5e-5)


''' 
Run NF-ULA initializing from the observation 'inpainting/figure_name/observation.pt' (this will imply a burn-in period)
or from a sample 'inpainting/figure_name/sample_ULA_NF.pt'.
If save_samples == True, samples (with size save_samples_size) will be saved to 'inpainting/figure_name/samples/ULA_NF_Samples.pt', 
and the last sample will be saved to'inpainting/figure_name/sample_ULA_NF.pt'. 
'''
# ULA_NF_test.ULA_NF_sample(start_from = "observation.pt", save_samples = False, save_samples_size = 10000, load_pt = pt_NF) # 
ULA_NF_test.ULA_NF_sample(start_from = "sample_ULA_NF.pt", save_samples = True, save_samples_size = 10000, load_pt = pt_NF) # 

######### Calculate the posterior mean and std from existing samples generated by NF-ULA.
ULA_NF_test.Quantification(samples = 'samples/ULA_NF_Samples.pt', colorbar_range = 0.12, algorithm = 'ULA_NF', network = 'Glow')

######### Run PnP-ULA using realSN-DnCNN. PnP-ULA is not very stable on this inpainting experiments. If the algorithm does not converge, try to load other pt_PnP.
# ULA_NF_test.PnP_ULA_sample(start_from = "observation.pt", save_samples = False, save_samples_size = 10000, load_pt = pt_PnP) # 
ULA_NF_test.PnP_ULA_sample(start_from = "sample_PnP_ULA.pt", save_samples = True, save_samples_size = 10000, load_pt = pt_PnP) # 

######### Calculate the posterior mean and std from existing samples generated by PnP-ULA, realSN-DnCNN.
ULA_NF_test.Quantification(samples = 'samples/PnP_ULA_Samples.pt', colorbar_range = 0.12, algorithm = 'PnP_ULA', network = 'realSN_DnCNN')

######### Calculate the autocorrelation function (ACF) of samples generated by NF-ULA and PnP-ULA. wavelet_type = 'YL' or 'YH'.
ULA_NF_test.ACF(wavelet = True, wavelet_type = 'YH', samples_NF = 'samples/ULA_NF_Samples.pt', samples_PnP = 'samples/PnP_ULA_Samples.pt')
